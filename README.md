# Week 3: Exception Handling and Java Collections

Welcome to the repository for **Week 3** of our Java learning journey. This week focused on robust error handling and working with Java’s built-in data structures using the **Collections Framework**.

---

##  Table of Contents

- [Overview](#overview)
- [Topics Covered](#topics-covered)
  - [Day 1: Linked lists](#day-1-linked-lists)
  - [Day 2: Stack and Queue](#day-2-stack-and-queue)
  - [Day 3: Sorting Algorithms](#day-3-sorting-algorithms)
  - [Day 4: Linear Search](#day-4-linear-search)
  - [Day 5: Binary Search](#day-5-binary-search)
  - [Day 6: Big O Notation](#day-6-big-o-notation)
- [Prerequisites](#prerequisites)
- [How to Use This Repository](#how-to-use-this-repository)

---

##  Overview

This week covered how to **handle runtime errors gracefully using exceptions** and explored core **data structures** provided by Java’s **Collections Framework**. You'll gain the ability to build **error-resilient** and **data-driven** applications using built-in tools for managing and organizing data effectively.

---

##  Topics Covered

###  Day 1: LinkedList

- Creating and modifying lists  
- Iterating through lists using loops and iterators  
- Differences between `ArrayList` and `LinkedList` in terms of performance and usage 

---

###  Day 2: Stack and Queue

- Understanding LIFO (Last In, First Out) and FIFO (First In, First Out) principles  
- Working with `Stack` and `Queue` interfaces in Java  
- Using `ArrayDeque` and `LinkedList` for stack and queue implementations  
- Common operations: `push()`, `pop()`, `peek()`, `offer()`, `poll()`, `element()`  

---

###  Day 3: Sorting Algorithms

- Introduction to basic sorting techniques  
- Implementing Bubble Sort, Selection Sort, and Insertion Sort in Java  
- Understanding time complexity and performance comparison  
- Sorting collections using `Collections.sort()` and custom comparators   

---

###  Day 4: Linear Search

- Concept of sequentially checking each element in an array  
- Suitable for unsorted or small datasets  
- Simple to implement and understand  
- Time complexity: O(n) in the worst case  
---

###  Day 5: binary Search

- Efficient searching technique for sorted arrays  
- Repeatedly divides the array in half to find the target  
- Requires careful implementation of low, high, and mid indices  
- Time complexity: O(log n) in the worst case   

---

###  Day 6: Big O Notation

- Understanding algorithm efficiency through time and space complexity  
- Introduction to Big O Notation for analyzing worst-case performance  
- Common complexities: O(1), O(log n), O(n), O(n log n), O(n²)  
- Practical tips for optimizing code and choosing efficient algorithms  
---

##  Prerequisites

Before starting Week 3, ensure the following:

- Java Development Kit (JDK) is installed and configured  
- An IDE such as **IntelliJ IDEA**, **Eclipse**, or **Visual Studio Code** is set up  
- You are familiar with Java fundamentals and OOP concepts from:  
  - **Week 1 – Core Java Programming**  
  - **Week 2 – Object-Oriented Programming in Java**

---

##  How to Use This Repository

Each folder in this repository corresponds to a specific day's topic. These folders include sample Java code, examples, and practice problems that reinforce the concepts discussed:

1. Explore each day’s folder to study the code examples  
2. Run the examples to observe the behavior of exception handling and collection operations  
3. Modify the code or add new examples to deepen your understanding  

This structure is designed to support **hands-on learning** and reinforce key concepts in **exception handling and collections**.

---
